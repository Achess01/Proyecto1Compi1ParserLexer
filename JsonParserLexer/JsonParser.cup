package com.achess.client.jsonParserLexer;
import java.util.List;
import java_cup.runtime.Symbol;
import com.achess.client.attribute.*;
import com.achess.client.jsonMembers.Comment;
import com.achess.client.jsonMembers.JavaClass;
import com.achess.client.jsonMembers.Method;
import com.achess.client.jsonMembers.Score;
import com.achess.client.jsonMembers.Variable;
import com.achess.client.error.Error;

parser code  {: 	
  
    public JsonParser(JsonLexer lexer){
        super(lexer);		
    }

    public void syntax_error(Symbol cur_token) {        
		List<Integer> tokens = expected_token_ids();
        int line = cur_token.left;
        int column = cur_token.right;
        String lexeme = symbl_name_from_id(cur_token.sym);
        String des = "Se esperaba:    \n";
        boolean count = false;
		for(Integer i : tokens) {	
            String fromId = symbl_name_from_id(i);                        
			des += fromId +" o ";                        
            count = true;
		}
        des = des.substring(0, des.length() - 3);

		Error.getError().log("Error sint√°ctico ln:"+line+" col:"+column+ " " +lexeme + "\n");		
		if(count) Error.getError().log(des+"\n");
	}

    public void report_fatal_error(String message, Object info) {
		Error.getError().log("Message: " + message);
		Error.getError().log("Info: " + info.toString());		
	}
    
:};

terminal LBRACE, RBRACE;
terminal LBRACKET, RBRACKET;
terminal COMMA, COLON;
//keys
terminal CLASSES_LITERAL, METHODS_LITERAL, VARIABLES_LITERAL, COMMENTS_LITERAL;
terminal SCORE_LITERAL;
terminal NAME_LITERAL, FUNCTION_LITERAL, TYPE_LITERAL, PARAMETERS_LITERAL;
terminal TEXT_LITERAL;
//values
terminal Integer INTEGER_LITERAL;
terminal String STRING_LITERAL;


non terminal initialState;
non terminal json_declaration;

non terminal ArrayList<Attribute> json_body;
non terminal Attribute json_body_item;

non terminal Attribute score_declaration;
non terminal Attribute variables_declaration;
non terminal Attribute methods_declaration;
non terminal Attribute classes_declaration;
non terminal Attribute comments_declaration;

non terminal ArrayList<Variable> list_variables_opt;
non terminal ArrayList<Variable> list_variables;
non terminal Variable variable_item;
non terminal Variable variable_item_body;

non terminal ArrayList<Method> list_methods_opt;
non terminal ArrayList<Method> list_methods;
non terminal Method method_item;
non terminal Method method_item_body;

non terminal ArrayList<JavaClass> list_classes_opt;
non terminal ArrayList<JavaClass> list_classes;
non terminal JavaClass class_item;
non terminal JavaClass class_item_body;

non terminal ArrayList<Comment> list_comments_opt;
non terminal ArrayList<Comment> list_comments;
non terminal Comment comment_item;
non terminal Comment comment_item_body;


non terminal String name_item;
non terminal String type_item;
non terminal String function_item;
non terminal Integer parameters_item;
non terminal String text_item;


start with initialState;


initialState ::= json_declaration
                ;

json_declaration ::= LBRACE json_body:body RBRACE
                    {:
                        if(Error.getError().isErrorFounded()){
                            ValidateJson.validate(body);
                        }
                    :}
                    ;

json_body ::= json_body_item:attr
            {:
                ArrayList<Attribute> attributes = new ArrayList();
                attributes.add(attr);
                RESULT=attributes;
            :}
            | json_body:arr COMMA json_body_item:attr
            {:
                arr.add(attr);
                RESULT=arr;
            :}
            | error json_body_item
            | error RBRACKET        
            ;

json_body_item ::=  score_declaration:attr
                {:
                    RESULT=attr;
                :}
                |   variables_declaration:attr
                {:
                    RESULT=attr;
                :}
                |   methods_declaration:attr
                {:
                    RESULT=attr;
                :}
                |   classes_declaration:attr
                {:
                    RESULT=attr;
                :}
                |   comments_declaration:attr           
                {:
                    RESULT=attr;
                :}
                ;

score_declaration ::=   SCORE_LITERAL COLON STRING_LITERAL
                        ;

variables_declaration ::=   VARIABLES_LITERAL COLON LBRACKET list_variables_opt RBRACKET
                            ;

list_variables_opt ::=  
                    |   list_variables
                    ;

list_variables ::=  variable_item
                |   list_variables COMMA variable_item                
                ;

variable_item ::=   LBRACE variable_item_body RBRACE
                    ;

variable_item_body ::=  name_item COMMA type_item COMMA function_item
                        ;                        
                        //Maybe add more productions to allow diferent orders

methods_declaration ::=   METHODS_LITERAL COLON LBRACKET list_methods_opt RBRACKET
                            ;

list_methods_opt ::=  
                    |   list_methods
                    ;

list_methods ::=  method_item
                |   list_methods COMMA method_item;

method_item ::=   LBRACE method_item_body RBRACE
                    ;

method_item_body ::=  name_item COMMA type_item COMMA parameters_item
                        ;                        
                        //Maybe add more productions to allow diferent orders     

classes_declaration ::=   CLASSES_LITERAL COLON LBRACKET list_classes_opt RBRACKET
                            ;

list_classes_opt ::=  
                    |   list_classes
                    ;

list_classes ::=  class_item
                |   list_classes COMMA class_item                                
                ;

class_item ::=   LBRACE class_item_body RBRACE
                    ;

class_item_body ::=  name_item
                        ;                        
                        //Maybe add more productions to allow diferent orders     
comments_declaration ::=   COMMENTS_LITERAL COLON LBRACKET list_comments_opt RBRACKET
                        ;

list_comments_opt ::=  
                    |   list_comments
                    ;

list_comments ::=  comment_item
                |   list_comments COMMA comment_item;

comment_item ::=   LBRACE comment_item_body RBRACE
                    ;

comment_item_body ::=  text_item
                        ;                        
                        //Maybe add more productions to allow diferent orders                             

name_item ::=   NAME_LITERAL COLON STRING_LITERAL
                ;

type_item ::=   TYPE_LITERAL COLON STRING_LITERAL
                ;

function_item ::=   FUNCTION_LITERAL COLON STRING_LITERAL
                    ;

parameters_item ::= PARAMETERS_LITERAL COLON INTEGER_LITERAL
                    ;

text_item ::=   TEXT_LITERAL COLON STRING_LITERAL
                ;

